# ğŸ“‹ How Generative AI Was Used in the FitTrack Project

This document provides a comprehensive and transparent breakdown of how Generative AI (such as GitHub Copilot and large language models) was utilized as a development tool and learning aid throughout the creation of this project.

---

## ğŸ¯ 1. Database Migration Assistance (MySQL â†’ SQLite)

### What AI Helped With:
- **Converted MySQL syntax to SQLite-compatible SQL**
  - Changed `AUTO_INCREMENT` â†’ `AUTOINCREMENT`
  - Changed `VARCHAR` â†’ `TEXT`
  - Adapted `DATETIME` â†’ `TIMESTAMP`
  - Modified foreign key constraints for SQLite compatibility

### Example Transformation:
```java
// MySQL (Original)
"CREATE TABLE users (\n"
+ "    user_id INT AUTO_INCREMENT PRIMARY KEY,\n"
+ "    username VARCHAR(50) NOT NULL UNIQUE,\n"

// SQLite (AI-Converted)
"CREATE TABLE IF NOT EXISTS users (\n"
+ "    user_id INTEGER PRIMARY KEY AUTOINCREMENT,\n"
+ "    username TEXT NOT NULL UNIQUE,\n"
```

### AI's Role:
âœ… Identified syntax incompatibilities
âœ… Provided SQLite-specific alternatives
âœ… Ensured data type mappings were correct
âœ… Added `IF NOT EXISTS` clauses for safety

---

## ğŸ”§ 2. JDBC Driver Configuration

### What AI Helped With:
```java
// AI-generated static block for SQLite driver loading
static {
    try {
        Class.forName("org.sqlite.JDBC");
    } catch (ClassNotFoundException e) {
        System.err.println("SQLite JDBC driver not found!");
        e.printStackTrace();
    }
}

// AI-updated connection string
private static final String DB_FILE = "fittrack.db";
private static final String DB_URL = "jdbc:sqlite:" + DB_FILE;
```

### AI's Role:
âœ… Explained why `Class.forName()` is needed
âœ… Showed how to construct SQLite JDBC URLs
âœ… Suggested storing DB file in project root
âœ… Added error handling for missing drivers

---

## ğŸ’¾ 3. CRUD Operation Refactoring

### What AI Helped With:

#### A. Handling NULL Values in SQLite
```java
// AI-added NULL handling for optional fields
if (user.age != null) {
    pstmt.setInt(1, user.age);
} else {
    pstmt.setNull(1, java.sql.Types.INTEGER);
}
```
**Why This Matters:**
SQLite doesn't handle NULL the same way as MySQL. AI ensured proper NULL value insertion.

---

#### B. Getting Auto-Generated IDs
```java
// MySQL way (didn't work in SQLite)
ResultSet rs = pstmt.getGeneratedKeys();

// SQLite way (AI-suggested)
try (Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT last_insert_rowid()")) {
    if (rs.next()) {
        goal.goalId = rs.getInt(1);
    }
}
```

### AI's Role:
âœ… Explained that SQLite uses `last_insert_rowid()`
âœ… Showed how to retrieve it after an `INSERT`
âœ… Applied this pattern consistently across all save methods

---

#### C. LocalDate Handling
```java
// AI-added proper date handling for SQLite
goal.targetDate = rs.getObject("target_date", LocalDate.class);

// When saving
pstmt.setObject(5, goal.targetDate);
```

### AI's Role:
âœ… Used `setObject()` and `getObject()` for modern date types
âœ… Ensured compatibility with Java 8+ date/time API
âœ… Avoided SQL injection risks

---

## ğŸ“Š 4. Enhanced Error Handling & Logging

### What AI Added:
```java
// AI-added detailed debug logging
System.out.println("DEBUG: Registering user: " + user.username);
System.out.println("DEBUG: Email: " + user.email);
System.out.println("DEBUG: Password hash: " + hashedPassword.substring(0, 20) + "...");

// AI-added console symbols for clarity
System.out.println("âœ“ User registered: " + user.username);
System.err.println("âœ— Registration error: " + e.getMessage());
```

### AI's Role:
âœ… Added emoji/symbols (âœ“, âœ—) for visual feedback
âœ… Suggested `printStackTrace()` for debugging
âœ… Implemented consistent logging patterns
âœ… Masked sensitive data (password hash preview only)

---

## ğŸ” 5. Security Enhancements

### What AI Suggested:

#### A. BCrypt Password Hashing
```java
// AI-recommended BCrypt over plain text
String hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());

// Verification
if (BCrypt.checkpw(password, storedHash)) {
